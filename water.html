<html>
<head>
    <title>Water</title>
    <style>
     html, body {
    width: 100%;
    height: 100%;
    margin: 0;
    padding: 0;
    background-color: black;
    overflow: hidden;
}

canvas {
    display: block;      /* removes inline-canvas whitespace */
    width: 100vw;
    height: 100vh;
}
    </style> 
</head>
<body>
    <canvas id="myCanvas" width="1200" height="800" style="border:1px solid #000000;"></canvas>
     <script defer>
        // see https://www.youtube.com/watch?v=f4s1h2YETNY
        const canvas = document.getElementById("myCanvas");
const gl = canvas.getContext("webgl2");

if (!gl) {
  throw new Error("WebGL not supported");
}

// ----- Vertex shader -----
const vsSource = `#version 300 es
precision mediump float;

in vec2 a_position;
out vec2 v_uv; 

uniform vec2 u_resolution;

void main() {
  v_uv = a_position;
  vec2 clip = a_position * 2.0 - 1.0;
  gl_Position = vec4(clip, 0, 1);
}
`;

// ----- Fragment shader -----
const fsSource = `#version 300 es
precision highp float;

out vec4 outColor;

uniform vec2 u_resolution;
uniform float u_time;

/* ------------------ Hash / Noise ------------------ */

float hash(vec2 p) {
    p = fract(p * vec2(123.34, 456.21));
    p += dot(p, p + 45.32);
    return fract(p.x * p.y);
}

float noise(vec2 p) {
    vec2 i = floor(p);
    vec2 f = fract(p);

    float a = hash(i);
    float b = hash(i + vec2(1.0, 0.0));
    float c = hash(i + vec2(0.0, 1.0));
    float d = hash(i + vec2(1.0, 1.0));

    vec2 u = f * f * (3.0 - 2.0 * f);

    return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);
}

/* ------------------ FBM ------------------ */

float fbm(vec2 p) {
    float value = 0.0;
    float amplitude = 0.5;

    for (int i = 0; i < 5; i++) {
        value += amplitude * noise(p);
        p *= 2.0;
        amplitude *= 0.5;
    }
    return value;
}

/* ------------------ Wave Height ------------------ */

float waveHeight(vec2 uv) {
    float t = u_time * 0.1;

    vec2 p = uv * 4.0;

    // Domain warping
    p += vec2(
        fbm(p + t),
        fbm(p - t)
    ) * 0.3;

    float waves =
        sin(p.x * 6.0 + t) +
        sin(p.y * 7.0 - t) +
        sin((p.x + p.y) * 4.0 + t);

    waves *= 0.1;
    waves += fbm(p + t) * 0.15;

    return waves;
}

/* ------------------ Normal from Height ------------------ */

vec3 computeNormal(vec2 uv) {
    float eps = 0.002;

    float h  = waveHeight(uv);
    float hx = waveHeight(uv + vec2(eps, 0.0));
    float hy = waveHeight(uv + vec2(0.0, eps));

    vec3 n = normalize(vec3(
        h - hx,
        h - hy,
        eps
    ));

    return n;
}

/* ------------------ Main ------------------ */

void main() {
    vec2 uv = gl_FragCoord.xy / u_resolution.xy;
    uv.x *= u_resolution.x / u_resolution.y;

    float h = waveHeight(uv);
    vec3 normal = computeNormal(uv);

    // Light direction
    vec3 lightDir = normalize(vec3(0.4, 0.6, 1.0));

    float diffuse = clamp(dot(normal, lightDir), 0.0, 1.0);

    vec3 waterColor = mix(
        vec3(0.02, 0.15, 0.25),
        vec3(0.05, 0.16, 0.27),
        diffuse
    );

    // Fresnel-ish effect
    float fresnel = pow(1.0 - normal.z, 3.0);
    waterColor += fresnel * 0.25;

    outColor = vec4(waterColor, 1.0);
}
`;

// ----- Compile shader -----
function createShader(gl, type, source) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
    throw new Error(gl.getShaderInfoLog(shader));
  }
  return shader;
}

const vertexShader = createShader(gl, gl.VERTEX_SHADER, vsSource);
const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fsSource);

// ----- Link program -----
const program = gl.createProgram();
gl.attachShader(program, vertexShader);
gl.attachShader(program, fragmentShader);
gl.linkProgram(program);
gl.useProgram(program);

// ----- Rectangle geometry (two triangles) -----
const vertices = new Float32Array([
   0.0 ,  0.0,  // v0 top-left
   1.0,  0.0,  // v1 top-right
   0.0, 1.0,  // v2 bottom-left
   1.0, 1.0   // v3 bottom-right
]);

const vao = gl.createVertexArray();
gl.bindVertexArray(vao);

gl.uniform2f(
  gl.getUniformLocation(program, "u_resolution"),
  canvas.width,
  canvas.height
);

const buffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

const positionLoc = gl.getAttribLocation(program, "a_position");
gl.enableVertexAttribArray(positionLoc);
gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);

const u_timeLoc = gl.getUniformLocation(program, "u_time");

gl.viewport(0, 0, canvas.width, canvas.height);

function render(time) {
  gl.clearColor(0, 0, 0, 1);   // black
  gl.clear(gl.COLOR_BUFFER_BIT);
  
  gl.uniform1f(u_timeLoc, time * 0.001);
  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  requestAnimationFrame(render);

}

requestAnimationFrame(render);

    </script>
</body>
</html>