<html>
<head>
    <title>Kaleidoskop</title>
    <style>
     html, body {
    width: 100%;
    height: 100%;
    margin: 0;
    padding: 0;
    background-color: black;
    overflow: hidden;
}

canvas {
    display: block;      /* removes inline-canvas whitespace */
    width: 100vw;
    height: 100vh;
}
    </style> 
</head>
<body>
    <canvas id="myCanvas" width="1200" height="800" style="border:1px solid #000000;"></canvas>
     <script defer>
        // see https://www.youtube.com/watch?v=f4s1h2YETNY
        const canvas = document.getElementById("myCanvas");
const gl = canvas.getContext("webgl2");

if (!gl) {
  throw new Error("WebGL not supported");
}

// ----- Vertex shader -----
const vsSource = `#version 300 es
precision mediump float;

in vec2 a_position;
out vec2 v_uv; 

uniform vec2 u_resolution;

void main() {
  v_uv = a_position;
  vec2 clip = a_position * 2.0 - 1.0;
  gl_Position = vec4(clip, 0, 1);
}
`;

// ----- Fragment shader -----
const fsSource = `#version 300 es
precision mediump float;

in vec2 v_uv;           // 0..1 screen position
uniform float u_time;
uniform vec2 u_resolution;
out vec4 outColor;

vec3 palette(float t) {
    vec3 a = vec3(0.5);
    vec3 b = vec3(0.5);
    vec3 c = vec3(1.0);
    vec3 d = vec3(0.00, 0.33, 0.67);
    return a + b * cos(6.28318 * (c * t + d));
}

void main() {
    vec2 uv = v_uv;
    vec2 uv0 = uv;
    vec3 final_color = vec3(0.0);
    for (int i = 0; i < 6; i++) {
        uv = fract(uv);
        float length_x = sin(uv.x*uv.y * 10.0-u_time*1.5);
        float length_y = sin(uv.y*uv.x * 15.0-u_time*1.7);
        vec3 color = palette(length(uv0)+u_time*0.5+float(i)*0.4);
        float sdf = abs(length_x);
        sdf = 0.02 / sdf;
        float sdf_y = 0.04 / abs(length_y);
        float s = smoothstep(0.0, 0.2, sdf)*smoothstep(0.0, 0.2, sdf_y);

        final_color += color * s;
        uv = uv * 3.0;
    }
    
    outColor = vec4(final_color, 1.0);
}
`;

// ----- Compile shader -----
function createShader(gl, type, source) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
    throw new Error(gl.getShaderInfoLog(shader));
  }
  return shader;
}

const vertexShader = createShader(gl, gl.VERTEX_SHADER, vsSource);
const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fsSource);

// ----- Link program -----
const program = gl.createProgram();
gl.attachShader(program, vertexShader);
gl.attachShader(program, fragmentShader);
gl.linkProgram(program);
gl.useProgram(program);

// ----- Rectangle geometry (two triangles) -----
const vertices = new Float32Array([
   0.0 ,  0.0,  // v0 top-left
   1.0,  0.0,  // v1 top-right
   0.0, 1.0,  // v2 bottom-left
   1.0, 1.0   // v3 bottom-right
]);

const vao = gl.createVertexArray();
gl.bindVertexArray(vao);

gl.uniform2f(
  gl.getUniformLocation(program, "u_resolution"),
  canvas.width,
  canvas.height
);

const buffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

const positionLoc = gl.getAttribLocation(program, "a_position");
gl.enableVertexAttribArray(positionLoc);
gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);

const u_timeLoc = gl.getUniformLocation(program, "u_time");

gl.viewport(0, 0, canvas.width, canvas.height);

function render(time) {
  gl.clearColor(0, 0, 0, 1);   // black
  gl.clear(gl.COLOR_BUFFER_BIT);
  
  gl.uniform1f(u_timeLoc, time * 0.001);
  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  requestAnimationFrame(render);

}

requestAnimationFrame(render);

    </script>
</body>
</html>