<html>
<head>
    <title>Symetric Tiles</title>
    <style>
     html, body {
    width: 100%;
    height: 100%;
    margin: 0;
    padding: 0;
    background-color: black;
    overflow: hidden;
}

canvas {
    display: block;      /* removes inline-canvas whitespace */
    width: 100vw;
    height: 100vh;
}
    </style> 
</head>
<body>
    <canvas id="myCanvas" width="1200" height="800" style="border:1px solid #000000;"></canvas>
     <script defer>
        // see https://www.youtube.com/watch?v=f4s1h2YETNY
        const canvas = document.getElementById("myCanvas");
const gl = canvas.getContext("webgl2");

if (!gl) {
  throw new Error("WebGL not supported");
}

// ----- Vertex shader -----
const vsSource = `#version 300 es
precision mediump float;

in vec2 a_position;
out vec2 v_uv; 

uniform vec2 u_resolution;

void main() {
  v_uv = a_position;
  vec2 clip = a_position * 2.0 - 1.0;
  gl_Position = vec4(clip, 0, 1);
}
`;

// ----- Fragment shader -----
const fsSource = `#version 300 es
precision highp float;

out vec4 outColor;

uniform vec2 u_resolution;
uniform float u_time;

/* ------------------ Hash / Noise ------------------ */

float hash(vec2 p) {
    p = fract(p * vec2(123.34, 456.21));
    p += dot(p, p + 45.32);
    return fract(p.x * p.y);
}

float noise(vec2 p) {
    vec2 i = floor(p);
    vec2 f = fract(p);

    float a = hash(i);
    float b = hash(i + vec2(1.0, 0.0));
    float c = hash(i + vec2(0.0, 1.0));
    float d = hash(i + vec2(1.0, 1.0));

    vec2 u = f * f * (3.0 - 2.0 * f);

    return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);
}

vec3 palette(float t) {
    vec3 a = vec3(0.5);
    vec3 b = vec3(0.5);
    vec3 c = vec3(1.0);
    vec3 d = vec3(0.00, 0.33, 0.67);
    return a + b * cos(6.28318 * (c * t + d));
}

void main() {
    vec2 uv = gl_FragCoord.xy / u_resolution.xy;
    // uv.x *= u_resolution.x / u_resolution.y;
    vec2 uv0 = uv;

    vec3 final_color = vec3(0.0);

    for (int i = 0; i < 3; i++) {
      vec2 tile = floor(uv * 2.0);
      vec2 f = fract(uv * 2.0);
      uv = mix(f, 1.0 - f, mod(tile+float(i), 2.0));

      float g = noise(uv*12.0 - u_time * 1.2);
      float s = smoothstep(0.5,0.9,g);
      final_color += palette(length(uv)+sin(u_time)*0.5+0.5) * s;
    }

    outColor = vec4(final_color.xyz, 1.0);
}
`;

// ----- Compile shader -----
function createShader(gl, type, source) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
    throw new Error(gl.getShaderInfoLog(shader));
  }
  return shader;
}

const vertexShader = createShader(gl, gl.VERTEX_SHADER, vsSource);
const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fsSource);

// ----- Link program -----
const program = gl.createProgram();
gl.attachShader(program, vertexShader);
gl.attachShader(program, fragmentShader);
gl.linkProgram(program);
gl.useProgram(program);

// ----- Rectangle geometry (two triangles) -----
const vertices = new Float32Array([
   0.0 ,  0.0,  // v0 top-left
   1.0,  0.0,  // v1 top-right
   0.0, 1.0,  // v2 bottom-left
   1.0, 1.0   // v3 bottom-right
]);

const vao = gl.createVertexArray();
gl.bindVertexArray(vao);

gl.uniform2f(
  gl.getUniformLocation(program, "u_resolution"),
  canvas.width,
  canvas.height
);

const buffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

const positionLoc = gl.getAttribLocation(program, "a_position");
gl.enableVertexAttribArray(positionLoc);
gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);

const u_timeLoc = gl.getUniformLocation(program, "u_time");

gl.viewport(0, 0, canvas.width, canvas.height);

function render(time) {
  gl.clearColor(0, 0, 0, 1);   // black
  gl.clear(gl.COLOR_BUFFER_BIT);
  
  gl.uniform1f(u_timeLoc, time * 0.001);
  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  requestAnimationFrame(render);

}

requestAnimationFrame(render);

    </script>
</body>
</html>