<html>
<head>
    <title>Retro Console</title>  
        <style>
     html, body {
    width: 100%;
    height: 100%;
    margin: 0;
    padding: 0;
    background-color: #0088ff;
    overflow: hidden;
}

body {
    display: flex;
    justify-content: center; /* horizontal */
    align-items: center;
}

canvas {
  display: block;
  image-rendering: pixelated;
  image-rendering: crisp-edges;
}
    </style> 
</head>
<body>
    <canvas id="myCanvas" width="1280" height="800" tabindex="-1" style="border:0px solid #000000;"></canvas>
     <script defer>
const canvas = document.getElementById("myCanvas");
const gl = canvas.getContext("webgl2");
if (!gl) throw new Error("WebGL2 required");

// ================== SHADERS ==================
const vsSource = `#version 300 es
in vec2 a_position;
in vec2 a_offset;
in vec2 a_size;
in vec2 a_texcoord;

uniform vec2 u_resolution;

out vec2 v_texcoord;

void main() {
    vec2 clip = a_position * 2.0 - 1.0;
    gl_Position = vec4(clip * vec2(1.0, -1.0), 0.0, 1.0);
    v_texcoord = a_texcoord;
}
`;

const fsSource = `#version 300 es
precision mediump float;

in vec2 v_texcoord;
uniform sampler2D u_texture;
uniform sampler2D u_charScreen;
uniform vec2 u_resolution;

out vec4 outColor;

void main() {
    vec2 u_screenSize = vec2(40.0, 25.0); // chars
    vec2 u_charSize = vec2(8.0, 8.0);   // pixels

    vec2 pixelPos = v_texcoord * u_screenSize * u_charSize; // pixel coords
    ivec2 charCell = ivec2(floor(pixelPos / u_charSize)); // 0..39,0..24

    // Lookup character code
    vec2 screenUV = (vec2(charCell) + 0.5) / u_screenSize;
    float charCode = texture(u_charScreen, screenUV).r * 255.0; // 0..255

    //  Compute character atlas coords
    int atlasCols = 16; // 16x16 chars
    float fCharCode = float(charCode);
    float atlasColsF = float(atlasCols);

    int atlasX = int(mod(fCharCode, atlasColsF));
    int atlasY = int(charCode / atlasColsF);

    //  Compute UV inside atlas
    vec2 charPixel = mod(pixelPos, u_charSize); // pixel inside character
    vec2 atlasUV = (vec2(atlasX, atlasY) * u_charSize + charPixel) / (u_charSize * atlasColsF);

    float value = texture(u_texture, atlasUV).r;
    vec3 color = mix(vec3(0.0,0.0,0.66), vec3(0.0,0.53,1.0), value);
    outColor = vec4(color, 1.0);
}
`;

// ================== UTILS ==================
function createShader(gl, type, src) {
    const s = gl.createShader(type);
    gl.shaderSource(s, src);
    gl.compileShader(s);
    if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
        throw new Error(gl.getShaderInfoLog(s));
    }
    return s;
}

function createProgram(gl, vs, fs) {
    const p = gl.createProgram();
    gl.attachShader(p, vs);
    gl.attachShader(p, fs);
    gl.linkProgram(p);
    if (!gl.getProgramParameter(p, gl.LINK_STATUS)) {
        throw new Error(gl.getProgramInfoLog(p));
    }
    return p;
}

// ================== PROGRAM ==================
const program = createProgram(
    gl,
    createShader(gl, gl.VERTEX_SHADER, vsSource),
    createShader(gl, gl.FRAGMENT_SHADER, fsSource)
);
gl.useProgram(program);

// ================== GEOMETRY ==================
const quadVertices = new Float32Array([
    0, 0,
    1, 0,
    0, 1,
    0, 1,
    1, 0,
    1, 1
]);

const texCoords = new Float32Array([
    0, 0,
    1, 0,
    0, 1,
    0, 1,
    1, 0,
    1, 1
]);

const quadBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, quadBuffer);
gl.bufferData(gl.ARRAY_BUFFER, quadVertices, gl.STATIC_DRAW);

const texBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, texBuffer);
gl.bufferData(gl.ARRAY_BUFFER, texCoords, gl.STATIC_DRAW);

// ================== INSTANCE DATA ==================
const cols = 40;
const rows = 25;

// Fill with example character codes (0-255)
const charScreen = new Uint8Array(cols * rows);
for (let i = 0; i < charScreen.length; i++) {
    charScreen[i] = i % 10 +1; // demo pattern
}

// ================== VAO ==================
const vao = gl.createVertexArray();
gl.bindVertexArray(vao);

// position
gl.bindBuffer(gl.ARRAY_BUFFER, quadBuffer);
const aPosLoc = gl.getAttribLocation(program, "a_position");
gl.enableVertexAttribArray(aPosLoc);
gl.vertexAttribPointer(aPosLoc, 2, gl.FLOAT, false, 0, 0);

// texcoord
gl.bindBuffer(gl.ARRAY_BUFFER, texBuffer);
const aTexLoc = gl.getAttribLocation(program, "a_texcoord");
gl.enableVertexAttribArray(aTexLoc);
gl.vertexAttribPointer(aTexLoc, 2, gl.FLOAT, false, 0, 0);


gl.bindVertexArray(null);


// ================== UNIFORMS ==================
const uResLoc = gl.getUniformLocation(program, "u_resolution");
gl.uniform2f(uResLoc, canvas.width, canvas.height);


const uScreenLoc = gl.getUniformLocation(program, "u_charScreen");
gl.uniform1i(uScreenLoc, 0);


// == screen state as texture ==

const screenTexture = gl.createTexture();
gl.bindTexture(gl.TEXTURE_2D, screenTexture);

// Use NEAREST filtering so each “byte” is exact
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

// Store as LUMINANCE texture (0..255)
gl.texImage2D(
    gl.TEXTURE_2D,
    0,
    gl.LUMINANCE,
    cols,
    rows,
    0,
    gl.LUMINANCE,
    gl.UNSIGNED_BYTE,
    charScreen
);

// ================== TEXTURE ==================
const texture = gl.createTexture();
gl.activeTexture(gl.TEXTURE0);
gl.bindTexture(gl.TEXTURE_2D, texture);
gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);

gl.texImage2D(
    gl.TEXTURE_2D,
    0,
    gl.RGBA,
    1,
    1,
    0,
    gl.RGBA,
    gl.UNSIGNED_BYTE,
    new Uint8Array([255, 0, 0, 255])
);

gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

gl.activeTexture(gl.TEXTURE1);
gl.bindTexture(gl.TEXTURE_2D, screenTexture);
gl.uniform1i(uScreenLoc, 1);

const img = new Image();
img.src = "8bit-0.png";
img.onload = () => {
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);
    requestAnimationFrame(render);
};

gl.bindTexture(gl.TEXTURE_2D, screenTexture);
gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, cols, rows, gl.LUMINANCE, gl.UNSIGNED_BYTE, charScreen);

// ================== RENDER ==================
gl.enable(gl.BLEND);
gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

let needScreenUpdate = false;

function toCharIndex(ascii) {
    if (ascii >= 65 && ascii < 91) {
        return ascii - 65 + 1; // A-Z
    } else if (ascii > 96 && ascii < 123) {
        return ascii - 97 + 1; // a-z
    } else if (ascii >= 32 && ascii <= 63) {
        return ascii; // direct mapping for other chars
    } else {
        return 0; // space
    }
}
let cursorX = 0;
let cursorY = 0;

function cls() {
    for (let i = 0; i < charScreen.length; i++) {
        charScreen[i] = 32; // space
    }
    cursorX = 0;
    cursorY = 0;
    needScreenUpdate = true;
}

function screen_print(msg) {
    for (let i = 0; i < msg.length; i++) {
        const c = msg.charCodeAt(i);
        if (c === 10) { // newline
            cursorX = 0;
            cursorY++;
            if (cursorY >= rows) {
                scroll_screen();
                cursorY = rows - 1;
            }
        } else {
            const charIndex = toCharIndex(c);
            charScreen[cursorY * cols + cursorX] = charIndex;
            cursorX++;
            if (cursorX >= cols) {
                cursorX = 0;
                cursorY++;
                if (cursorY >= rows) {
                    scroll_screen();
                    cursorY = rows - 1;
                }
            }
        }
    }
    needScreenUpdate = true;
}

function blink_cursor() {
    const index = cursorY * cols + cursorX;
    // flip 8th bit to create blinking effect
    charScreen[index] ^= 0x80;
    needScreenUpdate = true;
}

function cursor_move(diff_x, diff_y) {
    const index = cursorY * cols + cursorX;
    // delete 8th bit for normal state
    charScreen[index] &= 0x7F;
    cursorX += diff_x;
    cursorY += diff_y;
    if (cursorX >= cols) cursorX = cols - 1;
    if (cursorY >= rows) cursorY = rows - 1;
    if (cursorY < 0) cursorY = 0;
    needScreenUpdate = true;
}

cls();
screen_print("\n    This is a retro console demo.\n\nMade with webgl and fragment shader font display\nEnjoy!\n\nREADY.\n");

let lastBlink = 0;

function render(time) {
    gl.clearColor(0, 0, 0.66, 1);
    gl.clear(gl.COLOR_BUFFER_BIT);

    if (time - lastBlink > 350) {
        blink_cursor();
        lastBlink = time;
    }

    if (needScreenUpdate) {
        gl.activeTexture(gl.TEXTURE1);
        gl.bindTexture(gl.TEXTURE_2D, screenTexture);
        gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, cols, rows, gl.LUMINANCE, gl.UNSIGNED_BYTE, charScreen);
        needScreenUpdate = false;
    }

    gl.useProgram(program);
    gl.bindVertexArray(vao);
    gl.drawArrays(gl.TRIANGLES, 0, 6);

    requestAnimationFrame(render);
}

function charIndexToAscii(index) {
    if (index >= 1 && index <= 26) {
        return index - 1 + 65; // A-Z
    } else if (index >= 32 && index <= 63) {
        return index; // direct mapping for other chars
    } else {
        return 32; // space
    }
}

function getCurrentRow() {
    let row = "";
    for (let x = 0; x < cols; x++) {
        const index = charScreen[cursorY * cols + x];
        const ascii = charIndexToAscii(index & 0x7F); // ignore blink bit
        row += String.fromCharCode(ascii);
    }
    return row;
}

function scroll_screen() {
    for (let y = 1; y < rows; y++) {
        for (let x = 0; x < cols; x++) {
            charScreen[(y - 1) * cols + x] = charScreen[y * cols + x];
        }
    }
    // Clear last row
    for (let x = 0; x < cols; x++) {
        charScreen[(rows - 1) * cols + x] = toCharIndex(' '.charCodeAt(0)); // space
    }
}

let index = 0;
window.addEventListener("keydown", (e) => {
    switch (e.key) {
        case "ArrowLeft":
            cursor_move(-1, 0);
            break;
        case "ArrowRight":
            cursor_move(1, 0);
            break;
        case "ArrowUp":
            cursor_move(0, -1);
            break;
        case "ArrowDown":
            cursor_move(0, 1);
            break;
        case "Backspace":
        case "Delete":
            cursor_move(-1, 0);
            index = cursorY * cols + cursorX;
            charScreen[index] = toCharIndex(' '.charCodeAt(0)); // space
            break;
        case "Enter":
            {
                const row = getCurrentRow().trim();
                let result = undefined;
                if (row === "CLS") {
                    cls();
                    break;
                } else if (row === "DEMO") {
                    for (let i = 0; i < charScreen.length; i++) {
                        charScreen[i] = 77.5+Math.random();
                    }
                    needScreenUpdate = true;
                } else if (row === "HELP") {
                    result = "Commands: CLS, DEMO, HELP + eval JS";
                } else if (row !== "") {
                    try {
                        result = eval(row.trim().toLowerCase());
                    } catch (err) {                        
                        result = "ERROR?";
                    }
                }
                index = cursorY * cols + cursorX;
                charScreen[index] &= 0x7F;
                cursorX = 0;
                cursorY++;
                if (cursorY >= rows) {
                    scroll_screen();
                    cursorY = rows-1;
                }
                if (result !== undefined) {
                    const resultStr = String(result)+"\n";
                    screen_print(resultStr);
                }
                needScreenUpdate = true;
            }
            break;
        default:
            // For character input
            let char = e.key;
            if (char.length === 1) { // only single characters
                const index = cursorY * cols + cursorX;
                charScreen[index] = toCharIndex(char.charCodeAt(0)); // map to C64 char index
                cursorX++;
                if (cursorX >= cols) {
                    cursorX = 0;
                    cursorY = Math.min(rows - 1, cursorY + 1);
                }
            }
            needScreenUpdate = true;
            break;
    }
});

console.log("test");


    </script>
</body>
</html>