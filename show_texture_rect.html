<html>
<head>
    <title>My Web Page</title>  
</head>
<body>
    <h1>WebGL</h1>
    <canvas id="myCanvas" width="1200" height="800" style="border:1px solid #000000;"></canvas>
     <script defer>
const canvas = document.getElementById("myCanvas");
const gl = canvas.getContext("webgl2");
if (!gl) throw new Error("WebGL2 required");

// ================== SHADERS ==================
const vsSource = `#version 300 es
in vec2 a_position;
in vec2 a_offset;
in vec2 a_size;
in vec2 a_texcoord;

uniform vec2 u_resolution;

out vec2 v_texcoord;

void main() {
    vec2 pos = a_position * a_size + a_offset;

    vec2 zeroToOne = pos / u_resolution;
    vec2 clip = zeroToOne * 2.0 - 1.0;

    gl_Position = vec4(clip * vec2(1.0, -1.0), 0.0, 1.0);

    vec2 uvMin  = vec2(0.2, 0.2);
    vec2 uvSize = vec2(0.3, 0.3);

    v_texcoord = uvMin + a_texcoord * uvSize;
}
`;

const fsSource = `#version 300 es
precision mediump float;

in vec2 v_texcoord;
uniform sampler2D u_texture;

out vec4 outColor;

void main() {
    outColor = texture(u_texture, v_texcoord);
}
`;

// ================== UTILS ==================
function createShader(gl, type, src) {
    const s = gl.createShader(type);
    gl.shaderSource(s, src);
    gl.compileShader(s);
    if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
        throw new Error(gl.getShaderInfoLog(s));
    }
    return s;
}

function createProgram(gl, vs, fs) {
    const p = gl.createProgram();
    gl.attachShader(p, vs);
    gl.attachShader(p, fs);
    gl.linkProgram(p);
    if (!gl.getProgramParameter(p, gl.LINK_STATUS)) {
        throw new Error(gl.getProgramInfoLog(p));
    }
    return p;
}

// ================== PROGRAM ==================
const program = createProgram(
    gl,
    createShader(gl, gl.VERTEX_SHADER, vsSource),
    createShader(gl, gl.FRAGMENT_SHADER, fsSource)
);
gl.useProgram(program);

// ================== GEOMETRY ==================
const quadVertices = new Float32Array([
    0, 0,
    1, 0,
    0, 1,
    0, 1,
    1, 0,
    1, 1
]);

const texCoords = new Float32Array([
    0, 0,
    1, 0,
    0, 1,
    0, 1,
    1, 0,
    1, 1
]);

const quadBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, quadBuffer);
gl.bufferData(gl.ARRAY_BUFFER, quadVertices, gl.STATIC_DRAW);

const texBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, texBuffer);
gl.bufferData(gl.ARRAY_BUFFER, texCoords, gl.STATIC_DRAW);

// ================== INSTANCE DATA ==================
const maxRects = 10;

const instancePositions = new Float32Array(maxRects * 2);
const instanceSizes = new Float32Array(maxRects * 2);
const velocities = new Float32Array(maxRects * 2);

const offsetBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, offsetBuffer);
gl.bufferData(gl.ARRAY_BUFFER, instancePositions, gl.DYNAMIC_DRAW);

const sizeBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, sizeBuffer);
gl.bufferData(gl.ARRAY_BUFFER, instanceSizes, gl.DYNAMIC_DRAW);

// ================== VAO ==================
const vao = gl.createVertexArray();
gl.bindVertexArray(vao);

// position
gl.bindBuffer(gl.ARRAY_BUFFER, quadBuffer);
const aPosLoc = gl.getAttribLocation(program, "a_position");
gl.enableVertexAttribArray(aPosLoc);
gl.vertexAttribPointer(aPosLoc, 2, gl.FLOAT, false, 0, 0);

// texcoord
gl.bindBuffer(gl.ARRAY_BUFFER, texBuffer);
const aTexLoc = gl.getAttribLocation(program, "a_texcoord");
gl.enableVertexAttribArray(aTexLoc);
gl.vertexAttribPointer(aTexLoc, 2, gl.FLOAT, false, 0, 0);

// offset
gl.bindBuffer(gl.ARRAY_BUFFER, offsetBuffer);
const aOffsetLoc = gl.getAttribLocation(program, "a_offset");
gl.enableVertexAttribArray(aOffsetLoc);
gl.vertexAttribPointer(aOffsetLoc, 2, gl.FLOAT, false, 0, 0);
gl.vertexAttribDivisor(aOffsetLoc, 1);

// size
gl.bindBuffer(gl.ARRAY_BUFFER, sizeBuffer);
const aSizeLoc = gl.getAttribLocation(program, "a_size");
gl.enableVertexAttribArray(aSizeLoc);
gl.vertexAttribPointer(aSizeLoc, 2, gl.FLOAT, false, 0, 0);
gl.vertexAttribDivisor(aSizeLoc, 1);

gl.bindVertexArray(null);

// ================== UNIFORMS ==================
const uResLoc = gl.getUniformLocation(program, "u_resolution");
gl.uniform2f(uResLoc, canvas.width, canvas.height);

const uTexLoc = gl.getUniformLocation(program, "u_texture");
gl.uniform1i(uTexLoc, 0);

// ================== INIT DATA ==================
for (let i = 0; i < maxRects; i++) {
    instancePositions[i * 2] = Math.random() * (canvas.width - 128);
    instancePositions[i * 2 + 1] = Math.random() * (canvas.height - 128);
    instanceSizes[i * 2] = 128;
    instanceSizes[i * 2 + 1] = 128;
    velocities[i * 2] = (Math.random() - 0.5);
    velocities[i * 2 + 1] = (Math.random() - 0.5);
}

gl.bindBuffer(gl.ARRAY_BUFFER, offsetBuffer);
gl.bufferSubData(gl.ARRAY_BUFFER, 0, instancePositions);

gl.bindBuffer(gl.ARRAY_BUFFER, sizeBuffer);
gl.bufferSubData(gl.ARRAY_BUFFER, 0, instanceSizes);

// ================== TEXTURE ==================
const texture = gl.createTexture();
gl.activeTexture(gl.TEXTURE0);
gl.bindTexture(gl.TEXTURE_2D, texture);
gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);

gl.texImage2D(
    gl.TEXTURE_2D,
    0,
    gl.RGBA,
    1,
    1,
    0,
    gl.RGBA,
    gl.UNSIGNED_BYTE,
    new Uint8Array([255, 0, 0, 255])
);

gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);

const img = new Image();
img.src = "font.png";
img.onload = () => {
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);
    requestAnimationFrame(render);
};

// ================== RENDER ==================
gl.enable(gl.BLEND);
gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

function render() {
    gl.clearColor(0, 0, 0, 1);
    gl.clear(gl.COLOR_BUFFER_BIT);

    for (let i = 0; i < maxRects; i++) {
        instancePositions[i * 2] += velocities[i * 2];
        instancePositions[i * 2 + 1] += velocities[i * 2 + 1];

        if (instancePositions[i * 2] < 0 ||
            instancePositions[i * 2] > canvas.width - instanceSizes[i * 2]) {
            velocities[i * 2] *= -1;
        }
        if (instancePositions[i * 2 + 1] < 0 ||
            instancePositions[i * 2 + 1] > canvas.height - instanceSizes[i * 2 + 1]) {
            velocities[i * 2 + 1] *= -1;
        }
    }

    gl.bindBuffer(gl.ARRAY_BUFFER, offsetBuffer);
    gl.bufferSubData(gl.ARRAY_BUFFER, 0, instancePositions);

    gl.useProgram(program);
    gl.bindVertexArray(vao);
    gl.drawArraysInstanced(gl.TRIANGLES, 0, 6, maxRects);

    requestAnimationFrame(render);
}


    </script>
</body>
</html>